Permutation Computing in Coq
============================
The goal of this project is to develop a verified functional implementation of
the algorithms by O. Schreier, C. Sims, and T. Minkwitz using Coq. The combined
algorithm is able to efficiently give solutions to the permutation word problem:
given a group _G_ generated by a set of permutations _A_, determine if a
permutation _g_ lies in _G_, and if so produce a word in _A_ that is equivalent
to _g_. A short but comprehensive explanation of these algorithms can be found
in the following articles: [1], [2]. These articles have been archived in the
`doc` folder for future reference.

[1]: https://mathstrek.blog/2018/06/12/schreier-sims-algorithm/
[2]: https://mathstrek.blog/2018/06/21/solving-permutation-based-puzzles/

Puzzles
-------
The `E` prefixed files contain definitions of permutation puzzles, and examples
of using the algorithms that are implemented in this project. I hope that
analysis of Rubik's cube will be feasible within Coq. Note that the first three
puzzles only work well on computer screens, while the latter three exist as
physical objects.

1. **Cruzzle** I gave this name to a simple kind of turning puzzle. An image is
   cut into a grid where the rows and columns can revolve around. I found that
   some small instances, like 3×5, are more difficult than some larger ones.

2. **Twiddle** This puzzle is part of *Simon Tatham's Portable Puzzle
   Collection*, see [3]. It manipulates a grid by rotating four adjacent
   squares. I am curious how its complexity compares to Cruzzle.

3. **Inversion** This puzzle is part of te same collection as Twiddle, see [4].
   This time you can manipulate a grid by inverting a square and all direct
   neighbors. This puzzle could be extended to many different plane tilings.

4. **Topspin** This puzzle is used as case study in [2]. It works by rotating
   a sequence of numbers and reversing a fixed segment of them. This puzzle
   could be extended by adding other sequence manipulations.

5. **Sliding** The classic sliding puzzle is well known. It manipulates a grid
   by removing one square, and then continuouly moving adjacent squares into
   the empty square. This puzzle could work with different topologies.

6. **Rubik** Rubik's cube is perhaps the most famous of all permutation puzzles.
   It can be extended to many scales and dimensions, but in its most elegant
   form it already has approximately 43 quintillion combinations.

[3]: https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/twiddle.html
[4]: https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/flip.html

Composing functions versus adding puzzle moves
----------------------------------------------
Applying permutation functions is just like executing moves in a puzzle; they
both interchange certain values. But there is an important difference: function
composition and puzzle moves are applied in the opposite order! For example,
suppose σ and π represent permutations. When applying σ _after_ π, we would
write σ ∘ π. Curiously, the way to obtain the same result by executing σ and π
as puzzle moves is to _first_ execute σ and then execute π; from left to right!
This beautifully motivates the right to left composition of functions.

But why is this? A simple way to think about this is as follows. Suppose σ
represents a certain configuration of the puzzle, and we want to apply the move
π. The resulting configuration is _not_ π ∘ σ, but σ ∘ π. What will be the new
value at _n_? First we determine what index the move π places at n. Then we
determine what the current value at that index is, so: n ↦ σ(π(n)).
