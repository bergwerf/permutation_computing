(* Rubik's cube. *)

From CGT Require Import A1_setup A2_lists B1_fmap B2_perm B3_word B5_print.
From CGT Require Import C3_subgroup_chain D1_word_search.

Require Import String.
Local Open Scope string_scope.

(***
:: Rubiks' cube ::

Here we implement the permutations of Rubik's cube, and show how we can solve an
instance of the cube. We use the same notation and face numbering as ruwix.com
(see the doc folder). Although central cells do not need a number (they remain
fixed), we reserve a number for them anyway for convenience (to exactly follow
the numbering given in the doc folder).
*)
Module Rubiks_cube.

(*
  \  i | j | k  /
   ┏━━━┳━━━┳━━━┓
 t ┃ a ┃ b ┃ c ┃ l
---┣━━━╋━━━╋━━━┫---
 s ┃ h ┃   ┃ d ┃ m
---┣━━━╋━━━╋━━━┫---
 r ┃ g ┃ f ┃ e ┃ n
   ┗━━━┻━━━┻━━━┛
  /  q | p | o  \
*)
Definition rotation (a b c d e f g h i j k l m n o p q r s t : positive) := [
  [a; g; e; c; a]; [b; h; f; d; b];
  [i; r; o; l; i]; [j; s; p; m; j]; [k; t; q; n; k]
].

Definition gen_names := ["e"; "U"; "L"; "F"; "R"; "B"; "D"].
Definition gen : list perm := map Cycles.pack [
  rotation 01 02 03 06 09 08 07 04   39 38 37   30 29 28   21 20 19   12 11 10;
  rotation 10 11 12 15 18 17 16 13   01 04 07   19 22 25   46 49 52   45 42 39;
  rotation 19 20 21 24 27 26 25 22   07 08 09   28 31 34   48 47 46   18 15 12;
  rotation 28 29 30 33 36 35 34 31   09 06 03   37 40 43   54 51 48   27 24 21;
  rotation 37 38 39 42 45 44 43 40   03 02 01   10 13 16   52 53 54   36 33 30;
  rotation 46 47 48 51 54 53 52 49   25 26 27   34 35 36   43 44 45   16 17 18
].

(***
:: Solving order ::

We might solve the cube in the same order as is often done by hand: first solve
the top, then the middle, and finally the bottom. It turns out that the last two
blocks cannot be permuted (I don't know if this is always the case), so we find
a chain of 18 subgroups. I call this order A.

There are some alternative orders: (B) first fix all corners and then all edges,
(C) a bitwise ordering produced by `values (union_range gen)`. It turns out that
A is better than B and C, but C is slightly better than B. Perhaps fixing all
corners first really restrains movement for solving the edges. It should also be
noted that the upper bound is _very_ sensitive to the word search parameters.
*)

Definition order := [
  (* top side in circular order *)
  01; 02; 03; 06; 09; 08; 07; 04;
  (* middle edges in circular order *)
  13; 22; 31; 40;
  (* bottom side in circular order *)
  46; 47; 48; 51; 54; 53; 52; 49
].

Definition chain := SGChain.build gen order.

(* Computing this subgroup chain takes around half a minute. *)
(* Eval vm_compute in Minkwitz.save_orbits chain. *)

Definition orbits := [
  (01, 24%nat); (02, 24%nat); (03, 21%nat); (06, 22%nat); 
  (09, 18%nat); (08, 20%nat); (07, 15%nat); (04, 18%nat); 
  (13, 16%nat); (22, 14%nat); (31, 12%nat); (40, 10%nat); 
  (46, 12%nat); (47, 08%nat); (48, 09%nat); (51, 06%nat); 
  (54, 06%nat); (53, 2%nat)
].

(***
:: Number of configurations of Rubik's cube ::

Every configuration of Rubik's cube corresponds to a permutation generated by
rotations of the cube. Therefore the total number of configurations is equal to
the order of the permutation group we just defined. Using a theorem from group
theory we can compute this order as the product of all orbit lengths.
*)
Definition ord := fold_left Pos.mul (map (λ kn, Pos.of_nat (snd kn)) orbits) 1.
Eval lazy in ord.

(* Find a strong generating set. *)
Definition nontrivial_orbits := filter (λ kn, (1 <? snd kn)%nat) orbits.
Definition table := Minkwitz.initialize nontrivial_orbits.
Definition sgs := Minkwitz.fill table gen 30000 3000 20.

(***
:: Upper-bound on the length of solutions for Rubik's cube ::

Since every permutation can be factorized using a strong generating set, and
every such factorization uses one word from every row, we can compute the
maximum solution length by adding the length of the longest word in each row.

The upper bound computed from the selected subgroup chain and search parameters
is 201. This is not a very good upper bound; Rubik's cube can in general be
solved using at most 20 face turns (http://www.cube20.org/), but this result
required a specialized proof which took decades to discover.
*)
(* Eval vm_compute in Minkwitz.finished sgs. *)
Eval vm_compute in
  let word_length fw := List.length (snd fw) in
  let word_lengths := map (λ row, map word_length (values (snd row))) sgs in
  sum_list (map max_list word_lengths).

End Rubiks_cube.
