(* Minkwitz' brute-force short-word SGS search. *)

From CGT Require Import A1_setup B1_fmap B2_perm B3_word.
From CGT Require Import C1_Schreier_vector C3_subgroup_chain.

Module SGS.

Section Algorithm.

(***
:: Search table ::

The table is a list of triples (k, c, i ↦ (f, w)) representing each subgroup
generated by the Schreier-Sims algorithm. The only information needed from this
algorithm is the length of the orbits, such that the search can be terminated
when all generators are found. The triples carry the following information:
- The subgroup stabilizer point: k.
- The size of the orbit of k minus the orbit permutations already found: c.
- A map from an orbit value i to a flag f and a word w such that w is fully
  reduced and w maps i to k. The flag indicates if w is a new word.
*)
Definition orbit := fmap (bool × word).
Definition table := list (positive × nat × orbit).
Definition state := positive × nat × word × table.

(* Convert a subgroup chain to an orbit table. *)
Definition save_orbits (C : SGChain.chain) :=
  map (λ sg, match sg with (_, k, V) => (k, size V) end) C.

(* Initialize a triple given the stabilizer point k and orbit size n. *)
Definition initialize_triple (k : positive) (n : nat) :=
  (k, pred n, @create (bool × word) k (false, [])).

(* Create an empty SGS table from an orbit table. *)
Definition initialize (orbits : list (positive × nat)) :=
  map (λ kn, initialize_triple (fst kn) (snd kn)) orbits.

(* Determine if all orbits in the table are filled. *)
Fixpoint complete (T : table) :=
  match T with
  | [] => true
  | (_, O, _) :: T' => complete T'
  | _ => false
  end.

Section Fixed_generators.
Variable gen : generators.
Variable gen_size : positive.

Section Fixed_max_length.
Variable max_length : nat.

(* Subroutine of a round; add a new word to the orbit and try its inverse. *)
Definition round_finish (k : positive) (c : nat) (Ok : orbit) j w :=
  let w_inv := inv_word w in
  let Ok' := insert Ok j (true, w_inv) in
  let j' := apply_word gen w_inv k in
  match lookup Ok' j' with
  | None => (k, pred c, insert Ok' j' (true, w))
  | Some (_, w') =>
    if length_le_length w w'
    then (k, c, insert Ok' j' (true, w))
    else (k, c, Ok')
  end.

(* Update the table using the suggested word. *)
Fixpoint round (T : table) (w : word) : table :=
  if length_le_nat w max_length
  then match T with
  | [] => []
  | (k, c, Ok) :: T' =>
    let j := apply_word gen w k in
    match lookup Ok j with
    | None => round_finish k (pred c) Ok j w :: T'
    | Some (_, w') =>
      let w'' := reduce [] (w' ++ w) in
      let T'' := round T' w'' in
      if length_le_length w w'
      then round_finish k c Ok j w :: T''
      else (k, c, Ok) :: T''
    end
  end else T.

(* Clear all optimization flags in the given orbit. *)
Fixpoint clear_flags (O : orbit) :=
  match O with
  | Leaf => Leaf
  | Node None OO OI =>
    Node None (clear_flags OO) (clear_flags OI)
  | Node (Some (_, w)) OO OI =>
    Node (Some (false, w)) (clear_flags OO) (clear_flags OI)
  end.

(* Combine new short words for additional rounds. *)
Fixpoint recycle (T : table) : table :=
  match T with
  | [] => []
  | (k, c, Ok) :: T' =>
    let orbit_vals := values Ok in
    let vals_prod := list_prod orbit_vals orbit_vals in
    let new_table := (k, c, clear_flags Ok) :: recycle T' in
    let loop T' p :=
      (* For every two words w and w' in the k-orbit: *)
      match p with ((f, w), (f', w')) =>
        (* If either word is new; compute an extra round. *)
        if f || f' then round T' (reduce [] (w ++ w')) else T'
      end in
    fold_left loop vals_prod new_table
  end.

(* Complete higher orbits with words lower in the table (graph connectivity). *)
Fixpoint fill_orbits (T : table) : fmap (list (positive × word)) × table :=
  match T with
  | [] => (Leaf, [])
  | (k, c, Ok) :: T' =>
    let (sub, T'') := fill_orbits T' in
    let orbit_k := map (λ e, (fst e, snd (snd e))) (entries Ok xH) in
    let loop c_Ok i_w :=
      (* For every k-orbit entry (i, w): *)
      match i_w with (i, w) =>
        (* Does the subgroup chain contain an i-orbit? *)
        match lookup sub i with
        | None => c_Ok
        | Some i_orbit =>
          let loop' c_Ok' j_w :=
            (* For every i-orbit entry (j, w'): *)
            match c_Ok', j_w with (c', Ok'), (j, w') =>
              (* Note that w ++ w' is a word that maps j to k. *)
              (* Does the k-orbit already contain a word for j? *)
              match lookup Ok' j with
              | Some _ => c_Ok'
              | None =>
                (* Insert the new word if it is short enough. *)
                let w'' := reduce [] (w ++ w') in
                if length_le_nat w'' max_length
                then (pred c', insert Ok' j (true, w''))
                else c_Ok'
              end
            end in
          fold_left loop' i_orbit c_Ok
        end
      end in
    let (c', Ok') := fold_left loop orbit_k (c, Ok) in
    (insert sub k orbit_k, (k, c', Ok') :: T'')
  end.

End Fixed_max_length.

(* Add the next word to the table. *)
Definition cycle s_reset (S : state) : state :=
  match S with (s, l, w, T) =>
    let w' := next_word gen_size w in
    if (1 <? s) && length_le_nat w' l
    then
      let T' := round l T w' in
      (s - 1, l, w', T')
    else
      let T' := recycle l T in
      let T'' := snd (fill_orbits l T') in
      (s_reset, l + Nat.max 1 (l / 4), w, T'')%nat
  end.

(* Find a word to describe the permutation w ∘ π in T. *)
Fixpoint find_word (T : table) (w : word) (π : perm) :=
  match T with
  (* If the subgroup chain is complete, we must have w ∘ π = ident. *)
  | [] => Some []
  (* Otherwise map w ∘ π to the subgroup of T' by prepending a word. *)
  | (k, _, orbit) :: T' =>
    (* Compute j := (w ∘ π)⋅k. *)
    let j := apply_word gen w π⋅k in
    (* Find a word that maps j to k. *)
    match lookup orbit j with
    | Some (_, w_hd) =>
      match find_word T' (w_hd ++ w) π with
      (* w_tl = w_hd ∘ w ∘ π *)
      | Some w_tl => Some (inv_word w_hd ++ w_tl)
      | None => None
      end
    | None => None
    end
  end.

End Fixed_generators.

(***
:: Time bound ::

I believe that the search is certain to converge after checking all words of
length at most n! (track the maximum word length along the subgroup chain). Of
course in practice the search should converge _much_ faster.
*)

(* Apply f n times. *)
Fixpoint iter {X} n (f : X -> X) (x : X) : X :=
  match n with
  | 1 => f x
  | m~0 => iter m f (iter m f x)
  | m~1 => iter m f (iter m f (f x))
  end.

(***
Fill an SGS table.
- T: The table to fill.
- gen: The generating set.
- bound: Maximum number of cycles.
- s: Macro cycle size; recycle and orbit filling are done after every s cycles.
- l: Initial maximum word length; rounds are terminated beyond this length.
*)
Definition fill (T : table) (gen : list perm) bound s l : table :=
  let G := prepare_generators gen in
  let n := Pos.of_nat (length gen) in
  let S := iter bound (cycle G n s) (s, l, [], T) in
  snd S.

(* Find a permutation word using a strong generating set, and reduce it. *)
Definition factorize (T : table) (gen : list perm)  π : option word :=
  match find_word (prepare_generators gen) T [] π with
  | Some w => Some (reduce [] w)
  | None => None
  end.

(* Check the validity of all words in the table, and return the orbit sizes. *)
Fixpoint check_words (T : table) (gen : generators) (ks : list positive) :=
  match T with
  | [] => []
  | (k, _, Ok) :: T' =>
    let orbit := entries Ok xH in
    let valid := landb (map (λ e, match e with (i, (_, w)) =>
      landb (map (λ j, apply_word gen w j =? j) ks)
      && (k =? apply_word gen w i)
    end) orbit) in
    (k, length orbit, valid) ::
    check_words T' gen (k :: ks)
  end.

(* Determine if the table is valid. *)
Definition valid (T : table) (gen : list perm) orbits :=
  let G := prepare_generators gen in
  landb (map (λ p, match p with ((k, n), (l, m, b)) =>
    (k =? l) && (n =? m)%nat && b end)
  (combine orbits (check_words T G []))).

End Algorithm.

End SGS.
