(* Minkwitz' brute-force short-word generator search. *)

From CGT Require Import A1_setup B1_finite_map B2_permutation.

Module Minkwitz.

Section Algorithm.

(* The generating set. *)
Variable gen : list perm.

(* Letters to build permutations (positive for fast comparison). *)
Inductive gen_index :=
  | Forward (i : positive)
  | Inverse (i : positive).

(* Produce a permutation from a word (uncached inverses). *)
Fixpoint generate (word : list gen_index) :=
  match word with
  | [] => ident
  | Forward i :: w => nth (Pos.to_nat i) gen ident ∘ generate w
  | Inverse i :: w => inv (nth (Pos.to_nat i) gen ident) ∘ generate w
  end.

(* Check if two generators are opposite. *)
Definition opposite (a b : gen_index) :=
  match a, b with
  | Forward i, Inverse j => i =? j
  | Inverse j, Forward i => i =? j
  | _, _ => false
  end.

(* Remove redundant permutations from a word. *)
Fixpoint reduce (stack word : list gen_index) :=
  match word with
  | [] => rev stack
  | a :: w =>
    match stack with
    | [] => reduce [a] w
    | b :: s =>
      if opposite a b
      then reduce s w
      else reduce (a :: stack) w
    end
  end.

(***
:: Search table ::

The table is a list of triples (k, c, i ↦ π × w) representing each subgroup
generated by the Schreier-Sims algorithm. The only information needed from this
algorithm is the length of the orbits, such that the search can be terminated
when all generators are found. The triples carry the following information:
- The subgroup stabilizer point: k.
- The size of the orbit of k minus the orbit permutations already found: c.
- A map from an orbit value i to a permutation π and a word w such that:
  π maps k to i, π is generated by w, and w is fully reduced.
*)
Definition table := list (positive × nat × fmap (perm × list gen_index)).

End Algorithm.

End Minkwitz.
