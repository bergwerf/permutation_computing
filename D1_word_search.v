(* Minkwitz' brute-force short-word SGS search. *)

From CGT Require Import A1_setup B1_fmap B2_perm B3_word.
From CGT Require Import C1_Schreier_vector C3_subgroup_chain.

Module SGS.

Section Algorithm.

(***
:: Search table ::

The table is a list of triples (k, c, i ↦ (f, w)) representing each subgroup
generated by the Schreier-Sims algorithm. The only information needed from this
algorithm is the length of the orbits, such that the search can be terminated
when all generators are found. The triples carry the following information:
- The subgroup stabilizer point: k.
- The size of the orbit of k minus the orbit permutations already found: c.
- A map from an orbit value i to a flag f and a word w such that w is fully
  reduced and w maps k to i. The flag is used for periodic optimization. Note
  that in his paper T. Minkwitz stores words that map i to k (the inverse of
  what I do). There is no particular reason for my deviation from this.
*)
Definition orbit := fmap (bool × word).
Definition table := list (positive × nat × orbit).
Definition state := positive × nat × word × table.

(* Convert a subgroup chain to an orbit table. *)
Definition save_orbits (C : SGChain.chain) :=
  map (λ sg, match sg with (_, k, V) => (k, size V) end) C.

(* Initialize a triple given the stabilizer point k and orbit size n. *)
Definition initialize_triple (k : positive) (n : nat) :=
  (k, pred n, @create (bool × word) k (false, [])).

(* Create an empty SGS table from an orbit table. *)
Definition initialize (orbits : list (positive × nat)) :=
  map (λ kn, initialize_triple (fst kn) (snd kn)) orbits.

(* Determine if all orbits in the table are filled. *)
Fixpoint complete (T : table) :=
  match T with
  | [] => true
  | (_, O, _) :: T' => complete T'
  | _ => false
  end.

Section Fixed_generators.
Variable gen : generators.
Variable gen_size : positive.

Section Fixed_max_length.
Variable max_length : nat.

(* Try to add the given permutation to the table. *)
(* This algorithm does not try `inv_word w`, which can be a good candidate. *)
Fixpoint round (T : table) (w : word) : table :=
  if length_le_nat w max_length
  then match T with
  | [] => []
  | (k, c, Ok) :: T' =>
    let j := apply_word gen w k in
    match lookup Ok j with
    | None => (k, pred c, insert Ok j (true, w)) :: T'
    | Some (_, w') =>
      let w'' := reduce [] (inv_word w' ++ w) in
      let T'' := round T' w'' in
      if length_le_length w w'
      then (k, c, insert Ok j (true, w)) :: T''
      else (k, c, Ok) :: T''
    end
  end else T.

(* Clear all optimization flags in the given orbit. *)
Fixpoint clear_flags (O : orbit) :=
  match O with
  | Leaf => Leaf
  | Node None OO OI =>
    Node None (clear_flags OO) (clear_flags OI)
  | Node (Some (_, w)) OO OI =>
    Node (Some (false, w)) (clear_flags OO) (clear_flags OI)
  end.

(* Combine new short words for additional rounds. *)
Fixpoint recycle (T : table) : table :=
  match T with
  | [] => []
  | (k, c, Ok) :: T' =>
    let orbit_vals := values Ok in
    let vals_prod := list_prod orbit_vals orbit_vals in
    let new_table := (k, c, clear_flags Ok) :: recycle T' in
    let loop T' p :=
      (* For every two words w and w' in the k-orbit: *)
      match p with ((f, w), (f', w')) =>
        (* If either word is new: *)
        if f || f'
        then round T' (reduce [] (w ++ w'))
        else T'
      end in
    fold_left loop vals_prod new_table
  end.

(* Complete higher orbits with words lower in the table. *)
Fixpoint fill_orbits (T : table) : fmap (list (positive × word)) × table :=
  match T with
  | [] => (Leaf, [])
  | (k, c, Ok) :: T' =>
    let (sub, T'') := fill_orbits T' in
    let orbit_k := map (λ e, (fst e, snd (snd e))) (entries Ok xH) in
    let loop c_Ok i_w :=
      (* For every k-orbit entry (i, w): *)
      match i_w with (i, w) =>
        (* Does the subgroup chain contain an i-orbit? *)
        match lookup sub i with
        | None => c_Ok
        | Some i_orbit =>
          let loop' c_Ok' j_w :=
            (* For every i-orbit entry (j, w'): *)
            match c_Ok', j_w with (c', Ok'), (j, w') =>
              (* Note that w' ++ w is a word that maps k to j. *)
              (* Does the k-orbit already contain a word for j? *)
              match lookup Ok' j with
              | Some _ => c_Ok'
              | None =>
                (* Insert the new word if it is short enough. *)
                let w'' := reduce [] (w' ++ w) in
                if length_le_nat w'' max_length
                then (pred c', insert Ok' j (true, w''))
                else c_Ok'
              end
            end in
          fold_left loop' i_orbit c_Ok
        end
      end in
    let (c', Ok') := fold_left loop orbit_k (c, Ok) in
    (insert sub k orbit_k, (k, c', Ok') :: T'')
  end.

End Fixed_max_length.

(* Add the next word to the table. *)
Definition cycle s_reset (S : state) : state × bool :=
  match S with (s, l, w, T) =>
    let w' := next_word gen_size w in
    if (1 <? s) && length_le_nat w' l
    then
      let T' := round l T w' in
      (s - 1, l, w', T', complete T')
    else
      let T' := recycle l T in
      let T'' := snd (fill_orbits l T') in
      (s_reset, l + Nat.max 1 (l / 4), w, T'', complete T'')%nat
  end.

(* Find a word to describe the permutation w ∘ π in T. *)
Fixpoint find_word (T : table) (w : word) (π : perm) :=
  match T with
  (* If the subgroup chain is complete, we must have w ∘ π = ident. *)
  | [] => Some []
  (* Otherwise map w ∘ π to the subgroup of T' by prepending a word. *)
  | (k, _, orbit) :: T' =>
    (* Compute j := (w ∘ π)⋅k. *)
    let j := apply_word gen w π⋅k in
    (* Find a word that maps k to j in the k-orbit. *)
    match lookup orbit j with
    | Some (_, w_hd) =>
      match find_word T' (inv_word w_hd ++ w) π with
      | Some w_tl => Some (w_hd ++ w_tl)
      | None => None
      end
    | None => None
    end
  end.

End Fixed_generators.

(***
:: Time bound ::

I believe that the search is certain to converge after checking all words of
length at most n! (track the maximum word length along the subgroup chain). Of
course in practice the search should converge _much_ faster. In Coq all
functions must terminate, so to always finish the table we need to give a
theoretical upper bound. Since every cycle checks the next word, I think this
upper bound should be c^n!, where c is twice the size of the generating set. I
decided to let the user supply an upper-bound on the number of cycles.
*)

(* Apply f n times, or terminate when f returns (_, true). *)
Fixpoint iter {X} n (f : X -> X × bool) (x : X) : X × bool :=
  match n with
  | 1 => f x
  | m~0 =>
    match iter m f x with
    | (y, true) => (y, true)
    | (y, false) => iter m f y
    end
  | m~1 =>
    match f x with
    | (y, true) => (y, true)
    | (y, false) =>
      match iter m f y with
      | (z, true) => (z, true)
      | (z, false) => iter m f z
      end
    end
  end.

(***
Fill an SGS table.
- T: The table to fill.
- gen: The generating set.
- bound: Maximum number of cycles.
- s: Macro cycle size; recycle and orbit filling are done after every s cycles.
- l: Initial maximum word length; rounds are terminated beyond this length.
*)
Definition fill (T : table) (gen : list perm) bound s l : table :=
  let G := prepare_generators gen in
  let n := Pos.of_nat (length gen) in
  let S := iter bound (cycle G n s) (s, l, [], T) in
  snd (fst S).

(* Find a permutation word using a strong generating set, and reduce it. *)
Definition factorize (T : table) (gen : list perm)  π : option word :=
  match find_word (prepare_generators gen) T [] π with
  | Some w => Some (reduce [] w)
  | None => None
  end.

End Algorithm.

End SGS.
