(* Minkwitz' brute-force short-word SGS search. *)

From CGT Require Import A1_setup B1_fmap B2_perm B3_word.
From CGT Require Import C1_Schreier_vector C3_subgroup_chain.

Module Minkwitz.

Section Algorithm.

(***
:: Search table ::

The table is a list of triples (k, c, i ↦ (f, w)) representing each subgroup
generated by the Schreier-Sims algorithm. The only information needed from this
algorithm is the length of the orbits, such that the search can be terminated
when all generators are found. The triples carry the following information:
- The subgroup stabilizer point: k.
- The size of the orbit of k minus the orbit permutations already found: c.
- A map from an orbit value i to a flag f and a word w such that w is fully
  reduced and w maps k to i. The flag is used for periodic optimization.
*)
Definition table := list (positive × nat × fmap (bool × word)).
Definition state := word × table.

(* Determine if the table is filled out. *)
Fixpoint finished (T : table) :=
  match T with
  | [] => true
  | (_, O, _) :: T' => finished T'
  | _ => false
  end.

Section Fixed_generators.
Variable gen : generators.
Variable gen_size : positive.

Section Fixed_max_length.
Variable max_length : nat.

(* Try to add the given permutation to the table. *)
Fixpoint round (T : table) (w : word) : table :=
  if length_lt_nat w max_length
  then match T with
  | [] => []
  | (k, c, orbit) :: T' =>
    let j := apply_word gen w k in
    match lookup orbit j with
    | None => (k, pred c, insert orbit j (true, w)) :: T'
    | Some (_, w') =>
      if length_lt_length w w'
      then (k, c, insert orbit j (true, w)) :: T'
      else (k, c, orbit) :: round T' (reduce [] (inv_word w' ++ w))
    end
  end else T.

(* Clear all optimization flags in the given orbit. *)
Fixpoint clear_flags (orbit : fmap (bool × word)) :=
  match orbit with
  | Leaf => Leaf
  | Node None oO oI =>
    Node None (clear_flags oO) (clear_flags oI)
  | Node (Some (_, w)) oO oI =>
    Node (Some (false, w)) (clear_flags oO) (clear_flags oI)
  end.

(* Combine new short words for additional rounds. *)
Fixpoint recycle (T : table) {struct T} : table :=
  match T with
  | [] => []
  | (k, c, orbit) :: T' =>
    let orbit_vals := values orbit in
    let orbit_prod := list_prod orbit_vals orbit_vals in
    let new_table := (k, c, clear_flags orbit) :: recycle T' in
    let loop T' p :=
      match p with ((f, w), (f', w')) =>
        if orb f f'
        then round T' (w ++ w')
        else T'
      end in
    fold_left loop orbit_prod new_table
  end.

(* Fill higher orbits with results lower in the table. *)
(* Definition fill_orbits *)

End Fixed_max_length.

(* Add the next word to the table. *)
Definition step l (S : state) : state × bool :=
  match S with
  | (w, T) =>
    let w' := next_word gen_size w in
    let T' := round l T w' in
    (w', T', finished T')
  end.

End Fixed_generators.

(***
:: Time bound ::

I believe that the search is certain to converge after checking all words of
length at most n! (track the maximum word length along the subgroup chain). Of
course in practice the search should converge _much_ faster. In Coq all
functions must terminate, so to always finish the table we need to give a
theoretical upper bound. Since every step checks the next word, I think this
upper bound should be c^n!, where c is twice the size of the generating set. I
decided to let the user supply an upper-bound on the number of steps.
*)

(* Apply f n times, or terminate when f returns (_, true). *)
Fixpoint iter {X} n (f : X -> X × bool) (x : X) : X × bool :=
  match n with
  | 1 => f x
  | m~0 =>
    match iter m f x with
    | (y, true) => (y, true)
    | (y, false) => iter m f y
    end
  | m~1 =>
    match f x with
    | (y, true) => (y, true)
    | (y, false) =>
      match iter m f y with
      | (z, true) => (z, true)
      | (z, false) => iter m f z
      end
    end
  end.

(* Initialize a triple given the stabilizer point k and orbit size n. *)
Definition initialize_triple (k : positive) (n : nat) :=
  (k, pred n, @create (bool × word) k (true, [])).

(* Build a SGS table given a generating set and subgroup chain. *)
Definition sgs bound (gen : list perm) (C : SGChain.chain) : table :=
  let G := prepare_generators gen in
  let n := Pos.of_nat (length gen) in
  let T := map (λ sg, initialize_triple (snd (fst sg)) (size (snd sg))) C in
  let S := iter bound (step G n 5) ([], T) in
  snd (fst S).

End Algorithm.

End Minkwitz.
