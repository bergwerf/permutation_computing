(* Minkwitz' brute-force short-word SGS search. *)

From CGT Require Import A1_setup B1_fmap B2_perm B3_word.
From CGT Require Import C1_Schreier_vector C3_subgroup_chain.

Module Minkwitz.

Section Algorithm.

(***
:: Search table ::

The table is a list of triples (k, c, i ↦ (f, w)) representing each subgroup
generated by the Schreier-Sims algorithm. The only information needed from this
algorithm is the length of the orbits, such that the search can be terminated
when all generators are found. The triples carry the following information:
- The subgroup stabilizer point: k.
- The size of the orbit of k minus the orbit permutations already found: c.
- A map from an orbit value i to a flag f and a word w such that w is fully
  reduced and w maps k to i. The flag is used for periodic optimization.
*)
Definition table := list (positive × nat × fmap (bool × word)).
Definition state := word × table.

(* Determine if the table is filled out. *)
Fixpoint finished (T : table) :=
  match T with
  | [] => true
  | (_, O, _) :: T' => finished T'
  | _ => false
  end.

(* Try to add the given permutation to the table. *)
Fixpoint round (gen : generators) (T : table) (w : word) : table :=
  match T with
  | [] => []
  | (k, c, orbit) :: T' =>
    let j := apply_word gen w k in
    match lookup orbit j with
    | None => (k, pred c, insert orbit j (true, w)) :: T'
    | Some (_, w') =>
      if smaller w w'
      then (k, c, insert orbit j (true, w)) :: T'
      else (k, c, orbit) :: round gen T' (reduce [] (inv_word w' ++ w))
    end
  end.

(* Combine new short words for additional rounds. *)
(* Definition recycle *)

(* Fill higher orbits with results lower in the table. *)
(* Definition fill_orbits *)

(* Add the next word to the table. *)
Definition step gen n (S : state) : state × bool :=
  match S with
  | (w, T) =>
    let w' := next_word n w in
    let T' := round gen T w' in
    (w', T', finished T')
  end.

(***
:: Time bound ::

I believe that the search is certain to converge after checking all words of
length at most n! (track the maximum word length along the subgroup chain). Of
course in practice the search should converge _much_ faster. In Coq all
functions must terminate, so to always finish the table we need to give a
theoretical upper bound. Since every step checks the next word, I think this
upper bound should be c^n!, where c is twice the size of the generating set. I
decided to let the user supply an upper-bound on the number of steps.
*)

(* Apply f n times, or terminate when f returns (_, true). *)
Fixpoint iter {X} n (f : X -> X × bool) (x : X) : X × bool :=
  match n with
  | 1 => f x
  | m~0 =>
    match iter m f x with
    | (y, true) => (y, true)
    | (y, false) => iter m f y
    end
  | m~1 =>
    match f x with
    | (y, true) => (y, true)
    | (y, false) =>
      match iter m f y with
      | (z, true) => (z, true)
      | (z, false) => iter m f z
      end
    end
  end.

(* Initialize a triple given the stabilizer point k and orbit size n. *)
Definition initialize_triple (k : positive) (n : nat) :=
  (k, pred n, @create (bool × word) k (true, [])).

(* Build a SGS table given a generating set and subgroup chain. *)
Definition sgs bound (gen : list perm) (C : SGChain.chain) : table :=
  let gen' := prepare_generators gen in
  let n := Pos.of_nat (length gen) in
  let T := map (λ sg, initialize_triple (snd (fst sg)) (size (snd sg))) C in
  let S := iter bound (step gen' n) ([], T) in
  snd (fst S).

End Algorithm.

End Minkwitz.
